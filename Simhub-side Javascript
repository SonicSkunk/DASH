// ---- CLEAN SIMHUB SCRIPT (robust delta picker + tyre temps) ----
// CSV fields (returned):
// 0  RPM
// 1  SPEED
// 2  GEAR
// 3  POSITION
// 4  FUEL
// 5  LAP_MS
// 6  BEST_MS
// 7  DELTA_MS
// 8  MAXRPM
// 9  FLAG_Y
// 10 FLAG_B
// 11 FLAG_R
// 12 FLAG_G
// 13 CURRENT_LAP
// 14 TOTAL_LAPS
// 15 TYRE_FL (TyreTemperatureFrontLeft)
// 16 TYRE_FR (TyreTemperatureFrontRight)
// 17 TYRE_RL (TyreTemperatureRearLeft)
// 18 TYRE_RR (TyreTemperatureRearRight)
//
// NOTE: dash expects tyre temps in the order FL, FR, RL, RR at indices 15..18 (0-based).
// If your SimHub profile uses different property names, I included fallbacks: short-name (GameData.*)
// and DataCorePlugin prefix. Adjust if needed.

function safe(v){ return (v===null||v===undefined||v===""||v==="NaN"||isNaN(v)) ? 0 : v; }
function int(v){ v = safe(v); return Math.round(parseFloat(v)) || 0; }

function parseTimeMs(v){
  if (!v) return 0;
  let s = v.toString().trim();
  if (s.indexOf(":") < 0) {
    let sec = parseFloat(s);
    let ms = isNaN(sec) ? 0 : Math.round(sec * 1000);
    return (ms < 5000) ? 0 : ms;  // keep your cutoff
  }
  let p = s.split(":"); let h=0,m=0,sec=0;
  if (p.length===2){ m=parseFloat(p[0]); sec=parseFloat(p[1]); }
  else { h=parseFloat(p[0]); m=parseFloat(p[1]); sec=parseFloat(p[2]); }
  if (isNaN(h)||isNaN(m)||isNaN(sec)) return 0;
  let ms = Math.round(((h*3600)+(m*60)+sec)*1000);
  return (ms < 5000) ? 0 : ms;
}

// Try all known live/position-matched deltas. If value looks like seconds, convert to ms.
function pickDeltaMs(){
  const candidates = [
    // Position-matched deltas (most accurate)
    'PersistantTrackerPlugin.DeltaToSessionBestLap_Difference',
    'PersistantTrackerPlugin.DeltaToSessionBestLap.Difference',
    'PersistantTrackerPlugin.DeltaLive_Difference',
    'PersistantTrackerPlugin.DeltaLive.Difference',
    'PersistantTrackerPlugin.DeltaToReferenceLap_Difference',
    'PersistantTrackerPlugin.DeltaToReferenceLap.Difference',
    // Game-core variants seen in some titles/profiles
    'DataCorePlugin.GameData.DeltaToBestLap',
    'DataCorePlugin.GameData.DeltaBest',
    'DataCorePlugin.GameData.TimeDeltaBest',
    'DataCorePlugin.GameData.Delta',
  ];
  for (let k=0; k<candidates.length; k++){
    let raw = $prop(candidates[k]);
    if (raw === null || raw === undefined || raw === "" || raw === "NaN") continue;
    let val = parseFloat(raw);
    if (isNaN(val)) continue;
    // Heuristic: if magnitude < 600 itâ€™s seconds, else already ms
    let ms = Math.abs(val) < 600 ? Math.round(val * 1000) : Math.round(val);
    if (ms !== 0) return ms;
  }

  // Last resort: predictive estimate (your original source)
  let pred = parseFloat($prop('PersistantTrackerPlugin.EstimatedLapTime_SessionBestBasedSimhub_EstimatedDelta'));
  if (!isNaN(pred)) return Math.round(pred * 1000);

  return 0;
}

let rpm    = int($prop('DataCorePlugin.GameData.Rpms'));
let speed  = int($prop('DataCorePlugin.GameData.SpeedKmh'));
let gear   = int($prop('DataCorePlugin.GameData.Gear'));
let pos    = int($prop('DataCorePlugin.GameData.Position'));
let fuel   = int($prop('DataCorePlugin.GameData.FuelPercent'));
let maxRpm = int($prop('DataCorePlugin.GameData.MaxRpm'));

let lapMs  = parseTimeMs($prop('DataCorePlugin.GameData.LastLapTime')) ||
             parseTimeMs($prop('PersistantTrackerPlugin.LastLapTime')) || 0;

let bestMs = parseTimeMs($prop('DataCorePlugin.GameData.BestLapTime')) ||
             parseTimeMs($prop('PersistantTrackerPlugin.BestLapTime')) ||
             parseTimeMs($prop('PersistantTrackerPlugin.EstimatedLapTime_SessionBestBasedSimhub_ReferenceLapTime')) || 0;

let deltaMs = pickDeltaMs(); // negative = faster

let flagYellow = int($prop('DataCorePlugin.GameData.Flag_Yellow')) ? 1 : 0;
let flagBlue   = int($prop('DataCorePlugin.GameData.Flag_Blue'))   ? 1 : 0;
let flagRed    = int($prop('DataCorePlugin.GameData.Flag_Red'))    ? 1 : 0;
let flagGreen  = int($prop('DataCorePlugin.GameData.Flag_Green'))  ? 1 : 0;

// --- Lap counters (robust lookup across common property names) ---
let curLap = int($prop('DataCorePlugin.GameData.CurrentLap')) ||
             int($prop('PersistantTrackerPlugin.CurrentLap')) ||
             int($prop('GameData.CurrentLap')) || 0;

let totLaps = int($prop('DataCorePlugin.GameData.TotalLaps')) ||
              int($prop('PersistantTrackerPlugin.TotalLaps')) ||
              int($prop('GameData.TotalLaps')) || 0;

// --- Tyre temperatures (robust property lookup) ---
// Prefer DataCorePlugin.GameData.* but fall back to GameData.* names.
let tyreFL = int($prop('DataCorePlugin.GameData.TyreTemperatureFrontLeft')) ||
             int($prop('GameData.TyreTemperatureFrontLeft')) || 0;

let tyreFR = int($prop('DataCorePlugin.GameData.TyreTemperatureFrontRight')) ||
             int($prop('GameData.TyreTemperatureFrontRight')) || 0;

let tyreRL = int($prop('DataCorePlugin.GameData.TyreTemperatureRearLeft')) ||
             int($prop('GameData.TyreTemperatureRearLeft')) || 0;

let tyreRR = int($prop('DataCorePlugin.GameData.TyreTemperatureRearRight')) ||
             int($prop('GameData.TyreTemperatureRearRight')) || 0;

// Return CSV line: existing fields + curLap + totLaps + tyre temps (FL,FR,RL,RR)
return [
  rpm, speed, gear, pos, fuel,
  lapMs, bestMs, deltaMs, maxRpm,
  flagYellow, flagBlue, flagRed, flagGreen,
  curLap, totLaps,
  tyreFL, tyreFR, tyreRL, tyreRR
].join(',') + "\n";
